/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\nvar t = _interopRequire(__webpack_require__(1));\n\nconsole.log(t.map([1, 2, 3], function (x) {\n  return x + 1;\n}));\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvanMvbWFpbi5qcz82ZjIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7SUFBTyxDQUFDLHVDQUFNLENBQWdCOztBQUU5QixPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLFdBQUM7U0FBSSxDQUFDLEdBQUcsQ0FBQztDQUFBLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0IGZyb20gJ3RyYW5zZHVjZXJzLmpzJztcblxuY29uc29sZS5sb2codC5tYXAoWzEsIDIsIDNdLCB4ID0+IHggKyAxKSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3N0YXRpYy9qcy9tYWluLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIiLCJmaWxlIjoiMC5qcyJ9");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("\n// basic protocol helpers\n\nvar symbolExists = typeof Symbol !== 'undefined';\n\nvar protocols = {\n  iterator: symbolExists ? Symbol.iterator : '@@iterator',\n  transformer: symbolExists ? Symbol('transformer') : '@@transformer'\n};\n\nfunction throwProtocolError(name, coll) {\n  throw new Error(\"don't know how to \" + name + \" collection: \" +\n                  coll);\n}\n\nfunction fulfillsProtocol(obj, name) {\n  if(name === 'iterator') {\n    // Accept ill-formed iterators that don't conform to the\n    // protocol by accepting just next()\n    return obj[protocols.iterator] || obj.next;\n  }\n\n  return obj[protocols[name]];\n}\n\nfunction getProtocolProperty(obj, name) {\n  return obj[protocols[name]];\n}\n\nfunction iterator(coll) {\n  var iter = getProtocolProperty(coll, 'iterator');\n  if(iter) {\n    return iter.call(coll);\n  }\n  else if(coll.next) {\n    // Basic duck typing to accept an ill-formed iterator that doesn't\n    // conform to the iterator protocol (all iterators should have the\n    // @@iterator method and return themselves, but some engines don't\n    // have that on generators like older v8)\n    return coll;\n  }\n  else if(isArray(coll)) {\n    return new ArrayIterator(coll);\n  }\n  else if(isObject(coll)) {\n    return new ObjectIterator(coll);\n  }\n}\n\nfunction ArrayIterator(arr) {\n  this.arr = arr;\n  this.index = 0;\n}\n\nArrayIterator.prototype.next = function() {\n  if(this.index < this.arr.length) {\n    return {\n      value: this.arr[this.index++],\n      done: false\n    };\n  }\n  return {\n    done: true\n  }\n};\n\nfunction ObjectIterator(obj) {\n  this.obj = obj;\n  this.keys = Object.keys(obj);\n  this.index = 0;\n}\n\nObjectIterator.prototype.next = function() {\n  if(this.index < this.keys.length) {\n    var k = this.keys[this.index++];\n    return {\n      value: [k, this.obj[k]],\n      done: false\n    };\n  }\n  return {\n    done: true\n  }\n};\n\n// helpers\n\nvar toString = Object.prototype.toString;\nvar isArray = typeof Array.isArray === 'function' ? Array.isArray : function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\nfunction isObject(x) {\n  return x instanceof Object &&\n    Object.getPrototypeOf(x) === Object.getPrototypeOf({});\n}\n\nfunction isNumber(x) {\n  return typeof x === 'number';\n}\n\nfunction Reduced(value) {\n  this.__transducers_reduced__ = true;\n  this.value = value;\n}\n\nfunction isReduced(x) {\n  return (x instanceof Reduced) || (x && x.__transducers_reduced__);\n}\n\nfunction deref(x) {\n  return x.value;\n}\n\n/**\n * This is for transforms that may call their nested transforms before\n * Reduced-wrapping the result (e.g. \"take\"), to avoid nested Reduced.\n */\nfunction ensureReduced(val) {\n  if(isReduced(val)) {\n    return val;\n  } else {\n    return new Reduced(val);\n  }\n}\n\n/**\n * This is for tranforms that call their nested transforms when\n * performing completion (like \"partition\"), to avoid signaling\n * termination after already completing.\n */\nfunction ensureUnreduced(v) {\n  if(isReduced(v)) {\n    return deref(v);\n  } else {\n    return v;\n  }\n}\n\nfunction reduce(coll, xform, init) {\n  if(isArray(coll)) {\n    var result = init;\n    var index = -1;\n    var len = coll.length;\n    while(++index < len) {\n      result = xform.step(result, coll[index]);\n      if(isReduced(result)) {\n        result = deref(result);\n        break;\n      }\n    }\n    return xform.result(result);\n  }\n  else if(isObject(coll) || fulfillsProtocol(coll, 'iterator')) {\n    var result = init;\n    var iter = iterator(coll);\n    var val = iter.next();\n    while(!val.done) {\n      result = xform.step(result, val.value);\n      if(isReduced(result)) {\n        result = deref(result);\n        break;\n      }\n      val = iter.next();\n    }\n    return xform.result(result);\n  }\n  throwProtocolError('iterate', coll);\n}\n\nfunction transduce(coll, xform, reducer, init) {\n  xform = xform(reducer);\n  if(init === undefined) {\n    init = xform.init();\n  }\n  return reduce(coll, xform, init);\n}\n\nfunction compose() {\n  var funcs = Array.prototype.slice.call(arguments);\n  return function(r) {\n    var value = r;\n    for(var i=funcs.length-1; i>=0; i--) {\n      value = funcs[i](value);\n    }\n    return value;\n  }\n}\n\n// transformations\n\nfunction transformer(f) {\n  return {\n    init: function() {\n      throw new Error('init value unavailable');\n    },\n    result: function(v) {\n      return v;\n    },\n    step: f\n  };\n}\n\nfunction bound(f, ctx, count) {\n  count = count != null ? count : 1;\n\n  if(!ctx) {\n    return f;\n  }\n  else {\n    switch(count) {\n    case 1:\n      return function(x) {\n        return f.call(ctx, x);\n      }\n    case 2:\n      return function(x, y) {\n        return f.call(ctx, x, y);\n      }\n    default:\n      return f.bind(ctx);\n    }\n  }\n}\n\nfunction arrayMap(arr, f, ctx) {\n  var index = -1;\n  var length = arr.length;\n  var result = Array(length);\n  f = bound(f, ctx, 2);\n\n  while (++index < length) {\n    result[index] = f(arr[index], index);\n  }\n  return result;\n}\n\nfunction arrayFilter(arr, f, ctx) {\n  var len = arr.length;\n  var result = [];\n  f = bound(f, ctx, 2);\n\n  for(var i=0; i<len; i++) {\n    if(f(arr[i], i)) {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n}\n\nfunction Map(f, xform) {\n  this.xform = xform;\n  this.f = f;\n}\n\nMap.prototype.init = function() {\n  return this.xform.init();\n};\n\nMap.prototype.result = function(v) {\n  return this.xform.result(v);\n};\n\nMap.prototype.step = function(res, input) {\n  return this.xform.step(res, this.f(input));\n};\n\nfunction map(coll, f, ctx) {\n  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n\n  if(coll) {\n    if(isArray(coll)) {\n      return arrayMap(coll, f, ctx);\n    }\n    return seq(coll, map(f));\n  }\n\n  return function(xform) {\n    return new Map(f, xform);\n  }\n}\n\nfunction Filter(f, xform) {\n  this.xform = xform;\n  this.f = f;\n}\n\nFilter.prototype.init = function() {\n  return this.xform.init();\n};\n\nFilter.prototype.result = function(v) {\n  return this.xform.result(v);\n};\n\nFilter.prototype.step = function(res, input) {\n  if(this.f(input)) {\n    return this.xform.step(res, input);\n  }\n  return res;\n};\n\nfunction filter(coll, f, ctx) {\n  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n\n  if(coll) {\n    if(isArray(coll)) {\n      return arrayFilter(coll, f, ctx);\n    }\n    return seq(coll, filter(f));\n  }\n\n  return function(xform) {\n    return new Filter(f, xform);\n  };\n}\n\nfunction remove(coll, f, ctx) {\n  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n  return filter(coll, function(x) { return !f(x); });\n}\n\nfunction keep(coll) {\n  return filter(coll, function(x) { return x != null });\n}\n\nfunction Dedupe(xform) {\n  this.xform = xform;\n  this.last = undefined;\n}\n\nDedupe.prototype.init = function() {\n  return this.xform.init();\n};\n\nDedupe.prototype.result = function(v) {\n  return this.xform.result(v);\n};\n\nDedupe.prototype.step = function(result, input) {\n  if(input !== this.last) {\n    this.last = input;\n    return this.xform.step(result, input);\n  }\n  return result;\n};\n\nfunction dedupe(coll) {\n  if(coll) {\n    return seq(coll, dedupe());\n  }\n\n  return function(xform) {\n    return new Dedupe(xform);\n  }\n}\n\nfunction TakeWhile(f, xform) {\n  this.xform = xform;\n  this.f = f;\n}\n\nTakeWhile.prototype.init = function() {\n  return this.xform.init();\n};\n\nTakeWhile.prototype.result = function(v) {\n  return this.xform.result(v);\n};\n\nTakeWhile.prototype.step = function(result, input) {\n  if(this.f(input)) {\n    return this.xform.step(result, input);\n  }\n  return new Reduced(result);\n};\n\nfunction takeWhile(coll, f, ctx) {\n  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n\n  if(coll) {\n    return seq(coll, takeWhile(f));\n  }\n\n  return function(xform) {\n    return new TakeWhile(f, xform);\n  }\n}\n\nfunction Take(n, xform) {\n  this.n = n;\n  this.i = 0;\n  this.xform = xform;\n}\n\nTake.prototype.init = function() {\n  return this.xform.init();\n};\n\nTake.prototype.result = function(v) {\n  return this.xform.result(v);\n};\n\nTake.prototype.step = function(result, input) {\n  if (this.i < this.n) {\n    result = this.xform.step(result, input);\n    if(this.i + 1 >= this.n) {\n      // Finish reducing on the same step as the final value. TODO:\n      // double-check that this doesn't break any semantics\n      result = ensureReduced(result);\n    }\n  }\n  this.i++;\n  return result;\n};\n\nfunction take(coll, n) {\n  if(isNumber(coll)) { n = coll; coll = null }\n\n  if(coll) {\n    return seq(coll, take(n));\n  }\n\n  return function(xform) {\n    return new Take(n, xform);\n  }\n}\n\nfunction Drop(n, xform) {\n  this.n = n;\n  this.i = 0;\n  this.xform = xform;\n}\n\nDrop.prototype.init = function() {\n  return this.xform.init();\n};\n\nDrop.prototype.result = function(v) {\n  return this.xform.result(v);\n};\n\nDrop.prototype.step = function(result, input) {\n  if(this.i++ < this.n) {\n    return result;\n  }\n  return this.xform.step(result, input);\n};\n\nfunction drop(coll, n) {\n  if(isNumber(coll)) { n = coll; coll = null }\n\n  if(coll) {\n    return seq(coll, drop(n));\n  }\n\n  return function(xform) {\n    return new Drop(n, xform);\n  }\n}\n\nfunction DropWhile(f, xform) {\n  this.xform = xform;\n  this.f = f;\n  this.dropping = true;\n}\n\nDropWhile.prototype.init = function() {\n  return this.xform.init();\n};\n\nDropWhile.prototype.result = function(v) {\n  return this.xform.result(v);\n};\n\nDropWhile.prototype.step = function(result, input) {\n  if(this.dropping) {\n    if(this.f(input)) {\n      return result;\n    }\n    else {\n      this.dropping = false;\n    }\n  }\n  return this.xform.step(result, input);\n};\n\nfunction dropWhile(coll, f, ctx) {\n  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n\n  if(coll) {\n    return seq(coll, dropWhile(f));\n  }\n\n  return function(xform) {\n    return new DropWhile(f, xform);\n  }\n}\n\nfunction Partition(n, xform) {\n  this.n = n;\n  this.i = 0;\n  this.xform = xform;\n  this.part = new Array(n);\n}\n\nPartition.prototype.init = function() {\n  return this.xform.init();\n};\n\nPartition.prototype.result = function(v) {\n  if (this.i > 0) {\n    return ensureUnreduced(this.xform.step(v, this.part.slice(0, this.i)));\n  }\n  return this.xform.result(v);\n};\n\nPartition.prototype.step = function(result, input) {\n  this.part[this.i] = input;\n  this.i += 1;\n  if (this.i === this.n) {\n    var out = this.part.slice(0, this.n);\n    this.part = new Array(this.n);\n    this.i = 0;\n    return this.xform.step(result, out);\n  }\n  return result;\n};\n\nfunction partition(coll, n) {\n  if (isNumber(coll)) {\n    n = coll; coll = null;\n  }\n\n  if (coll) {\n    return seq(coll, partition(n));\n  }\n\n  return function(xform) {\n    return new Partition(n, xform);\n  };\n}\n\nvar NOTHING = {};\n\nfunction PartitionBy(f, xform) {\n  // TODO: take an \"opts\" object that allows the user to specify\n  // equality\n  this.f = f;\n  this.xform = xform;\n  this.part = [];\n  this.last = NOTHING;\n}\n\nPartitionBy.prototype.init = function() {\n  return this.xform.init();\n};\n\nPartitionBy.prototype.result = function(v) {\n  var l = this.part.length;\n  if (l > 0) {\n    return ensureUnreduced(this.xform.step(v, this.part.slice(0, l)));\n  }\n  return this.xform.result(v);\n};\n\nPartitionBy.prototype.step = function(result, input) {\n  var current = this.f(input);\n  if (current === this.last || this.last === NOTHING) {\n    this.part.push(input);\n  } else {\n    result = this.xform.step(result, this.part);\n    this.part = [input];\n  }\n  this.last = current;\n  return result;\n};\n\nfunction partitionBy(coll, f, ctx) {\n  if (isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n\n  if (coll) {\n    return seq(coll, partitionBy(f));\n  }\n\n  return function(xform) {\n    return new PartitionBy(f, xform);\n  };\n}\n\n// pure transducers (cannot take collections)\n\nfunction Cat(xform) {\n  this.xform = xform;\n}\n\nCat.prototype.init = function() {\n  return this.xform.init();\n};\n\nCat.prototype.result = function(v) {\n  return this.xform.result(v);\n};\n\nCat.prototype.step = function(result, input) {\n  var xform = this.xform;\n  var newxform = {\n    init: function() {\n      return xform.init();\n    },\n    result: function(v) {\n      return v;\n    },\n    step: function(result, input) {\n      var val = xform.step(result, input);\n      return isReduced(val) ? deref(val) : val;\n    }\n  }\n\n  return reduce(input, newxform, result);\n};\n\nfunction cat(xform) {\n  return new Cat(xform);\n}\n\nfunction mapcat(f, ctx) {\n  f = bound(f, ctx);\n  return compose(map(f), cat);\n}\n\n// collection helpers\n\nfunction push(arr, x) {\n  arr.push(x);\n  return arr;\n}\n\nfunction merge(obj, x) {\n  if(isArray(x) && x.length === 2) {\n    obj[x[0]] = x[1];\n  }\n  else {\n    var keys = Object.keys(x);\n    var len = keys.length;\n    for(var i=0; i<len; i++) {\n      obj[keys[i]] = x[keys[i]];\n    }\n  }\n  return obj;\n}\n\nvar arrayReducer = {\n  init: function() {\n    return [];\n  },\n  result: function(v) {\n    return v;\n  },\n  step: push\n}\n\nvar objReducer = {\n  init: function() {\n    return {};\n  },\n  result: function(v) {\n    return v;\n  },\n  step: merge\n};\n\nfunction getReducer(coll) {\n  if(isArray(coll)) {\n    return arrayReducer;\n  }\n  else if(isObject(coll)) {\n    return objReducer;\n  }\n  else if(fulfillsProtocol(coll, 'transformer')) {\n    return getProtocolProperty(coll, 'transformer');\n  }\n  throwProtocolError('getReducer', coll);\n}\n\n// building new collections\n\nfunction toArray(coll, xform) {\n  if(!xform) {\n    return reduce(coll, arrayReducer, []);\n  }\n  return transduce(coll, xform, arrayReducer, []);\n}\n\nfunction toObj(coll, xform) {\n  if(!xform) {\n    return reduce(coll, objReducer, {});\n  }\n  return transduce(coll, xform, objReducer, {});\n}\n\nfunction toIter(coll, xform) {\n  if(!xform) {\n    return iterator(coll);\n  }\n  return new LazyTransformer(xform, coll);\n}\n\nfunction seq(coll, xform) {\n  if(isArray(coll)) {\n    return transduce(coll, xform, arrayReducer, []);\n  }\n  else if(isObject(coll)) {\n    return transduce(coll, xform, objReducer, {});\n  }\n  else if(fulfillsProtocol(coll, 'transformer')) {\n    var transformer = getProtocolProperty(coll, 'transformer');\n    return transduce(coll, xform, transformer, transformer.init());\n  }\n  else if(fulfillsProtocol(coll, 'iterator')) {\n    return new LazyTransformer(xform, coll);\n  }\n  throwProtocolError('sequence', coll);\n}\n\nfunction into(to, xform, from) {\n  if(isArray(to)) {\n    return transduce(from, xform, arrayReducer, to);\n  }\n  else if(isObject(to)) {\n    return transduce(from, xform, objReducer, to);\n  }\n  else if(fulfillsProtocol(to, 'transformer')) {\n    return transduce(from,\n                     xform,\n                     getProtocolProperty(to, 'transformer'),\n                     to);\n  }\n  throwProtocolError('into', to);\n}\n\n// laziness\n\nvar stepper = {\n  result: function(v) {\n    return isReduced(v) ? deref(v) : v;\n  },\n  step: function(lt, x) {\n    lt.items.push(x);\n    return lt.rest;\n  }\n}\n\nfunction Stepper(xform, iter) {\n  this.xform = xform(stepper);\n  this.iter = iter;\n}\n\nStepper.prototype.step = function(lt) {\n  var len = lt.items.length;\n  while(lt.items.length === len) {\n    var n = this.iter.next();\n    if(n.done || isReduced(n.value)) {\n      // finalize\n      this.xform.result(this);\n      break;\n    }\n\n    // step\n    this.xform.step(lt, n.value);\n  }\n}\n\nfunction LazyTransformer(xform, coll) {\n  this.iter = iterator(coll);\n  this.items = [];\n  this.stepper = new Stepper(xform, iterator(coll));\n}\n\nLazyTransformer.prototype[protocols.iterator] = function() {\n  return this;\n}\n\nLazyTransformer.prototype.next = function() {\n  this.step();\n\n  if(this.items.length) {\n    return {\n      value: this.items.pop(),\n      done: false\n    }\n  }\n  else {\n    return { done: true };\n  }\n};\n\nLazyTransformer.prototype.step = function() {\n  if(!this.items.length) {\n    this.stepper.step(this);\n  }\n}\n\n// util\n\nfunction range(n) {\n  var arr = new Array(n);\n  for(var i=0; i<arr.length; i++) {\n    arr[i] = i;\n  }\n  return arr;\n}\n\n\nmodule.exports = {\n  reduce: reduce,\n  transformer: transformer,\n  Reduced: Reduced,\n  iterator: iterator,\n  push: push,\n  merge: merge,\n  transduce: transduce,\n  seq: seq,\n  toArray: toArray,\n  toObj: toObj,\n  toIter: toIter,\n  into: into,\n  compose: compose,\n  map: map,\n  filter: filter,\n  remove: remove,\n  cat: cat,\n  mapcat: mapcat,\n  keep: keep,\n  dedupe: dedupe,\n  take: take,\n  takeWhile: takeWhile,\n  drop: drop,\n  dropWhile: dropWhile,\n  partition: partition,\n  partitionBy: partitionBy,\n  range: range,\n\n  protocols: protocols,\n  LazyTransformer: LazyTransformer\n};\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RyYW5zZHVjZXJzLmpzL3RyYW5zZHVjZXJzLmpzP2IzNmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFNBQVMsVUFBVSxhQUFhO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixTQUFTLFVBQVUsYUFBYTtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsU0FBUyxVQUFVLGFBQWE7QUFDeEQ7QUFDQSxtQ0FBbUMsY0FBYyxFQUFFO0FBQ25EOztBQUVBO0FBQ0EsbUNBQW1DLG1CQUFtQjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFNBQVMsVUFBVSxhQUFhO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFVBQVU7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFVBQVU7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixTQUFTLFVBQVUsYUFBYTtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsU0FBUyxVQUFVLGFBQWE7QUFDekQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBiYXNpYyBwcm90b2NvbCBoZWxwZXJzXG5cbnZhciBzeW1ib2xFeGlzdHMgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcblxudmFyIHByb3RvY29scyA9IHtcbiAgaXRlcmF0b3I6IHN5bWJvbEV4aXN0cyA/IFN5bWJvbC5pdGVyYXRvciA6ICdAQGl0ZXJhdG9yJyxcbiAgdHJhbnNmb3JtZXI6IHN5bWJvbEV4aXN0cyA/IFN5bWJvbCgndHJhbnNmb3JtZXInKSA6ICdAQHRyYW5zZm9ybWVyJ1xufTtcblxuZnVuY3Rpb24gdGhyb3dQcm90b2NvbEVycm9yKG5hbWUsIGNvbGwpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiZG9uJ3Qga25vdyBob3cgdG8gXCIgKyBuYW1lICsgXCIgY29sbGVjdGlvbjogXCIgK1xuICAgICAgICAgICAgICAgICAgY29sbCk7XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGxzUHJvdG9jb2wob2JqLCBuYW1lKSB7XG4gIGlmKG5hbWUgPT09ICdpdGVyYXRvcicpIHtcbiAgICAvLyBBY2NlcHQgaWxsLWZvcm1lZCBpdGVyYXRvcnMgdGhhdCBkb24ndCBjb25mb3JtIHRvIHRoZVxuICAgIC8vIHByb3RvY29sIGJ5IGFjY2VwdGluZyBqdXN0IG5leHQoKVxuICAgIHJldHVybiBvYmpbcHJvdG9jb2xzLml0ZXJhdG9yXSB8fCBvYmoubmV4dDtcbiAgfVxuXG4gIHJldHVybiBvYmpbcHJvdG9jb2xzW25hbWVdXTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvdG9jb2xQcm9wZXJ0eShvYmosIG5hbWUpIHtcbiAgcmV0dXJuIG9ialtwcm90b2NvbHNbbmFtZV1dO1xufVxuXG5mdW5jdGlvbiBpdGVyYXRvcihjb2xsKSB7XG4gIHZhciBpdGVyID0gZ2V0UHJvdG9jb2xQcm9wZXJ0eShjb2xsLCAnaXRlcmF0b3InKTtcbiAgaWYoaXRlcikge1xuICAgIHJldHVybiBpdGVyLmNhbGwoY29sbCk7XG4gIH1cbiAgZWxzZSBpZihjb2xsLm5leHQpIHtcbiAgICAvLyBCYXNpYyBkdWNrIHR5cGluZyB0byBhY2NlcHQgYW4gaWxsLWZvcm1lZCBpdGVyYXRvciB0aGF0IGRvZXNuJ3RcbiAgICAvLyBjb25mb3JtIHRvIHRoZSBpdGVyYXRvciBwcm90b2NvbCAoYWxsIGl0ZXJhdG9ycyBzaG91bGQgaGF2ZSB0aGVcbiAgICAvLyBAQGl0ZXJhdG9yIG1ldGhvZCBhbmQgcmV0dXJuIHRoZW1zZWx2ZXMsIGJ1dCBzb21lIGVuZ2luZXMgZG9uJ3RcbiAgICAvLyBoYXZlIHRoYXQgb24gZ2VuZXJhdG9ycyBsaWtlIG9sZGVyIHY4KVxuICAgIHJldHVybiBjb2xsO1xuICB9XG4gIGVsc2UgaWYoaXNBcnJheShjb2xsKSkge1xuICAgIHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcihjb2xsKTtcbiAgfVxuICBlbHNlIGlmKGlzT2JqZWN0KGNvbGwpKSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RJdGVyYXRvcihjb2xsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBBcnJheUl0ZXJhdG9yKGFycikge1xuICB0aGlzLmFyciA9IGFycjtcbiAgdGhpcy5pbmRleCA9IDA7XG59XG5cbkFycmF5SXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5pbmRleCA8IHRoaXMuYXJyLmxlbmd0aCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdGhpcy5hcnJbdGhpcy5pbmRleCsrXSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRvbmU6IHRydWVcbiAgfVxufTtcblxuZnVuY3Rpb24gT2JqZWN0SXRlcmF0b3Iob2JqKSB7XG4gIHRoaXMub2JqID0gb2JqO1xuICB0aGlzLmtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICB0aGlzLmluZGV4ID0gMDtcbn1cblxuT2JqZWN0SXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5pbmRleCA8IHRoaXMua2V5cy5sZW5ndGgpIHtcbiAgICB2YXIgayA9IHRoaXMua2V5c1t0aGlzLmluZGV4KytdO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogW2ssIHRoaXMub2JqW2tdXSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRvbmU6IHRydWVcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzQXJyYXkgPSB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PT0gJ2Z1bmN0aW9uJyA/IEFycmF5LmlzQXJyYXkgOiBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIE9iamVjdCAmJlxuICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KTtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBSZWR1Y2VkKHZhbHVlKSB7XG4gIHRoaXMuX190cmFuc2R1Y2Vyc19yZWR1Y2VkX18gPSB0cnVlO1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGlzUmVkdWNlZCh4KSB7XG4gIHJldHVybiAoeCBpbnN0YW5jZW9mIFJlZHVjZWQpIHx8ICh4ICYmIHguX190cmFuc2R1Y2Vyc19yZWR1Y2VkX18pO1xufVxuXG5mdW5jdGlvbiBkZXJlZih4KSB7XG4gIHJldHVybiB4LnZhbHVlO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgZm9yIHRyYW5zZm9ybXMgdGhhdCBtYXkgY2FsbCB0aGVpciBuZXN0ZWQgdHJhbnNmb3JtcyBiZWZvcmVcbiAqIFJlZHVjZWQtd3JhcHBpbmcgdGhlIHJlc3VsdCAoZS5nLiBcInRha2VcIiksIHRvIGF2b2lkIG5lc3RlZCBSZWR1Y2VkLlxuICovXG5mdW5jdGlvbiBlbnN1cmVSZWR1Y2VkKHZhbCkge1xuICBpZihpc1JlZHVjZWQodmFsKSkge1xuICAgIHJldHVybiB2YWw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBSZWR1Y2VkKHZhbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGZvciB0cmFuZm9ybXMgdGhhdCBjYWxsIHRoZWlyIG5lc3RlZCB0cmFuc2Zvcm1zIHdoZW5cbiAqIHBlcmZvcm1pbmcgY29tcGxldGlvbiAobGlrZSBcInBhcnRpdGlvblwiKSwgdG8gYXZvaWQgc2lnbmFsaW5nXG4gKiB0ZXJtaW5hdGlvbiBhZnRlciBhbHJlYWR5IGNvbXBsZXRpbmcuXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZVVucmVkdWNlZCh2KSB7XG4gIGlmKGlzUmVkdWNlZCh2KSkge1xuICAgIHJldHVybiBkZXJlZih2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2UoY29sbCwgeGZvcm0sIGluaXQpIHtcbiAgaWYoaXNBcnJheShjb2xsKSkge1xuICAgIHZhciByZXN1bHQgPSBpbml0O1xuICAgIHZhciBpbmRleCA9IC0xO1xuICAgIHZhciBsZW4gPSBjb2xsLmxlbmd0aDtcbiAgICB3aGlsZSgrK2luZGV4IDwgbGVuKSB7XG4gICAgICByZXN1bHQgPSB4Zm9ybS5zdGVwKHJlc3VsdCwgY29sbFtpbmRleF0pO1xuICAgICAgaWYoaXNSZWR1Y2VkKHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gZGVyZWYocmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4Zm9ybS5yZXN1bHQocmVzdWx0KTtcbiAgfVxuICBlbHNlIGlmKGlzT2JqZWN0KGNvbGwpIHx8IGZ1bGZpbGxzUHJvdG9jb2woY29sbCwgJ2l0ZXJhdG9yJykpIHtcbiAgICB2YXIgcmVzdWx0ID0gaW5pdDtcbiAgICB2YXIgaXRlciA9IGl0ZXJhdG9yKGNvbGwpO1xuICAgIHZhciB2YWwgPSBpdGVyLm5leHQoKTtcbiAgICB3aGlsZSghdmFsLmRvbmUpIHtcbiAgICAgIHJlc3VsdCA9IHhmb3JtLnN0ZXAocmVzdWx0LCB2YWwudmFsdWUpO1xuICAgICAgaWYoaXNSZWR1Y2VkKHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gZGVyZWYocmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YWwgPSBpdGVyLm5leHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHhmb3JtLnJlc3VsdChyZXN1bHQpO1xuICB9XG4gIHRocm93UHJvdG9jb2xFcnJvcignaXRlcmF0ZScsIGNvbGwpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2R1Y2UoY29sbCwgeGZvcm0sIHJlZHVjZXIsIGluaXQpIHtcbiAgeGZvcm0gPSB4Zm9ybShyZWR1Y2VyKTtcbiAgaWYoaW5pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaW5pdCA9IHhmb3JtLmluaXQoKTtcbiAgfVxuICByZXR1cm4gcmVkdWNlKGNvbGwsIHhmb3JtLCBpbml0KTtcbn1cblxuZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgdmFyIGZ1bmNzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHIpIHtcbiAgICB2YXIgdmFsdWUgPSByO1xuICAgIGZvcih2YXIgaT1mdW5jcy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICB2YWx1ZSA9IGZ1bmNzW2ldKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8vIHRyYW5zZm9ybWF0aW9uc1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1lcihmKSB7XG4gIHJldHVybiB7XG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXQgdmFsdWUgdW5hdmFpbGFibGUnKTtcbiAgICB9LFxuICAgIHJlc3VsdDogZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfSxcbiAgICBzdGVwOiBmXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJvdW5kKGYsIGN0eCwgY291bnQpIHtcbiAgY291bnQgPSBjb3VudCAhPSBudWxsID8gY291bnQgOiAxO1xuXG4gIGlmKCFjdHgpIHtcbiAgICByZXR1cm4gZjtcbiAgfVxuICBlbHNlIHtcbiAgICBzd2l0Y2goY291bnQpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gZi5jYWxsKGN0eCwgeCk7XG4gICAgICB9XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIGYuY2FsbChjdHgsIHgsIHkpO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZi5iaW5kKGN0eCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFycmF5TWFwKGFyciwgZiwgY3R4KSB7XG4gIHZhciBpbmRleCA9IC0xO1xuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gIGYgPSBib3VuZChmLCBjdHgsIDIpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGYoYXJyW2luZGV4XSwgaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFyciwgZiwgY3R4KSB7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGYgPSBib3VuZChmLCBjdHgsIDIpO1xuXG4gIGZvcih2YXIgaT0wOyBpPGxlbjsgaSsrKSB7XG4gICAgaWYoZihhcnJbaV0sIGkpKSB7XG4gICAgICByZXN1bHQucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBNYXAoZiwgeGZvcm0pIHtcbiAgdGhpcy54Zm9ybSA9IHhmb3JtO1xuICB0aGlzLmYgPSBmO1xufVxuXG5NYXAucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm0uaW5pdCgpO1xufTtcblxuTWFwLnByb3RvdHlwZS5yZXN1bHQgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0aGlzLnhmb3JtLnJlc3VsdCh2KTtcbn07XG5cbk1hcC5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKHJlcywgaW5wdXQpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm0uc3RlcChyZXMsIHRoaXMuZihpbnB1dCkpO1xufTtcblxuZnVuY3Rpb24gbWFwKGNvbGwsIGYsIGN0eCkge1xuICBpZihpc0Z1bmN0aW9uKGNvbGwpKSB7IGN0eCA9IGY7IGYgPSBjb2xsOyBjb2xsID0gbnVsbDsgfVxuICBmID0gYm91bmQoZiwgY3R4KTtcblxuICBpZihjb2xsKSB7XG4gICAgaWYoaXNBcnJheShjb2xsKSkge1xuICAgICAgcmV0dXJuIGFycmF5TWFwKGNvbGwsIGYsIGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBzZXEoY29sbCwgbWFwKGYpKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih4Zm9ybSkge1xuICAgIHJldHVybiBuZXcgTWFwKGYsIHhmb3JtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBGaWx0ZXIoZiwgeGZvcm0pIHtcbiAgdGhpcy54Zm9ybSA9IHhmb3JtO1xuICB0aGlzLmYgPSBmO1xufVxuXG5GaWx0ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm0uaW5pdCgpO1xufTtcblxuRmlsdGVyLnByb3RvdHlwZS5yZXN1bHQgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0aGlzLnhmb3JtLnJlc3VsdCh2KTtcbn07XG5cbkZpbHRlci5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKHJlcywgaW5wdXQpIHtcbiAgaWYodGhpcy5mKGlucHV0KSkge1xuICAgIHJldHVybiB0aGlzLnhmb3JtLnN0ZXAocmVzLCBpbnB1dCk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIGZpbHRlcihjb2xsLCBmLCBjdHgpIHtcbiAgaWYoaXNGdW5jdGlvbihjb2xsKSkgeyBjdHggPSBmOyBmID0gY29sbDsgY29sbCA9IG51bGw7IH1cbiAgZiA9IGJvdW5kKGYsIGN0eCk7XG5cbiAgaWYoY29sbCkge1xuICAgIGlmKGlzQXJyYXkoY29sbCkpIHtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihjb2xsLCBmLCBjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gc2VxKGNvbGwsIGZpbHRlcihmKSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oeGZvcm0pIHtcbiAgICByZXR1cm4gbmV3IEZpbHRlcihmLCB4Zm9ybSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShjb2xsLCBmLCBjdHgpIHtcbiAgaWYoaXNGdW5jdGlvbihjb2xsKSkgeyBjdHggPSBmOyBmID0gY29sbDsgY29sbCA9IG51bGw7IH1cbiAgZiA9IGJvdW5kKGYsIGN0eCk7XG4gIHJldHVybiBmaWx0ZXIoY29sbCwgZnVuY3Rpb24oeCkgeyByZXR1cm4gIWYoeCk7IH0pO1xufVxuXG5mdW5jdGlvbiBrZWVwKGNvbGwpIHtcbiAgcmV0dXJuIGZpbHRlcihjb2xsLCBmdW5jdGlvbih4KSB7IHJldHVybiB4ICE9IG51bGwgfSk7XG59XG5cbmZ1bmN0aW9uIERlZHVwZSh4Zm9ybSkge1xuICB0aGlzLnhmb3JtID0geGZvcm07XG4gIHRoaXMubGFzdCA9IHVuZGVmaW5lZDtcbn1cblxuRGVkdXBlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnhmb3JtLmluaXQoKTtcbn07XG5cbkRlZHVwZS5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdGhpcy54Zm9ybS5yZXN1bHQodik7XG59O1xuXG5EZWR1cGUucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gIGlmKGlucHV0ICE9PSB0aGlzLmxhc3QpIHtcbiAgICB0aGlzLmxhc3QgPSBpbnB1dDtcbiAgICByZXR1cm4gdGhpcy54Zm9ybS5zdGVwKHJlc3VsdCwgaW5wdXQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBkZWR1cGUoY29sbCkge1xuICBpZihjb2xsKSB7XG4gICAgcmV0dXJuIHNlcShjb2xsLCBkZWR1cGUoKSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oeGZvcm0pIHtcbiAgICByZXR1cm4gbmV3IERlZHVwZSh4Zm9ybSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVGFrZVdoaWxlKGYsIHhmb3JtKSB7XG4gIHRoaXMueGZvcm0gPSB4Zm9ybTtcbiAgdGhpcy5mID0gZjtcbn1cblxuVGFrZVdoaWxlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnhmb3JtLmluaXQoKTtcbn07XG5cblRha2VXaGlsZS5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdGhpcy54Zm9ybS5yZXN1bHQodik7XG59O1xuXG5UYWtlV2hpbGUucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gIGlmKHRoaXMuZihpbnB1dCkpIHtcbiAgICByZXR1cm4gdGhpcy54Zm9ybS5zdGVwKHJlc3VsdCwgaW5wdXQpO1xuICB9XG4gIHJldHVybiBuZXcgUmVkdWNlZChyZXN1bHQpO1xufTtcblxuZnVuY3Rpb24gdGFrZVdoaWxlKGNvbGwsIGYsIGN0eCkge1xuICBpZihpc0Z1bmN0aW9uKGNvbGwpKSB7IGN0eCA9IGY7IGYgPSBjb2xsOyBjb2xsID0gbnVsbDsgfVxuICBmID0gYm91bmQoZiwgY3R4KTtcblxuICBpZihjb2xsKSB7XG4gICAgcmV0dXJuIHNlcShjb2xsLCB0YWtlV2hpbGUoZikpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHhmb3JtKSB7XG4gICAgcmV0dXJuIG5ldyBUYWtlV2hpbGUoZiwgeGZvcm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRha2UobiwgeGZvcm0pIHtcbiAgdGhpcy5uID0gbjtcbiAgdGhpcy5pID0gMDtcbiAgdGhpcy54Zm9ybSA9IHhmb3JtO1xufVxuXG5UYWtlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnhmb3JtLmluaXQoKTtcbn07XG5cblRha2UucHJvdG90eXBlLnJlc3VsdCA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm0ucmVzdWx0KHYpO1xufTtcblxuVGFrZS5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgaWYgKHRoaXMuaSA8IHRoaXMubikge1xuICAgIHJlc3VsdCA9IHRoaXMueGZvcm0uc3RlcChyZXN1bHQsIGlucHV0KTtcbiAgICBpZih0aGlzLmkgKyAxID49IHRoaXMubikge1xuICAgICAgLy8gRmluaXNoIHJlZHVjaW5nIG9uIHRoZSBzYW1lIHN0ZXAgYXMgdGhlIGZpbmFsIHZhbHVlLiBUT0RPOlxuICAgICAgLy8gZG91YmxlLWNoZWNrIHRoYXQgdGhpcyBkb2Vzbid0IGJyZWFrIGFueSBzZW1hbnRpY3NcbiAgICAgIHJlc3VsdCA9IGVuc3VyZVJlZHVjZWQocmVzdWx0KTtcbiAgICB9XG4gIH1cbiAgdGhpcy5pKys7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiB0YWtlKGNvbGwsIG4pIHtcbiAgaWYoaXNOdW1iZXIoY29sbCkpIHsgbiA9IGNvbGw7IGNvbGwgPSBudWxsIH1cblxuICBpZihjb2xsKSB7XG4gICAgcmV0dXJuIHNlcShjb2xsLCB0YWtlKG4pKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih4Zm9ybSkge1xuICAgIHJldHVybiBuZXcgVGFrZShuLCB4Zm9ybSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gRHJvcChuLCB4Zm9ybSkge1xuICB0aGlzLm4gPSBuO1xuICB0aGlzLmkgPSAwO1xuICB0aGlzLnhmb3JtID0geGZvcm07XG59XG5cbkRyb3AucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm0uaW5pdCgpO1xufTtcblxuRHJvcC5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdGhpcy54Zm9ybS5yZXN1bHQodik7XG59O1xuXG5Ecm9wLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICBpZih0aGlzLmkrKyA8IHRoaXMubikge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHRoaXMueGZvcm0uc3RlcChyZXN1bHQsIGlucHV0KTtcbn07XG5cbmZ1bmN0aW9uIGRyb3AoY29sbCwgbikge1xuICBpZihpc051bWJlcihjb2xsKSkgeyBuID0gY29sbDsgY29sbCA9IG51bGwgfVxuXG4gIGlmKGNvbGwpIHtcbiAgICByZXR1cm4gc2VxKGNvbGwsIGRyb3AobikpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHhmb3JtKSB7XG4gICAgcmV0dXJuIG5ldyBEcm9wKG4sIHhmb3JtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEcm9wV2hpbGUoZiwgeGZvcm0pIHtcbiAgdGhpcy54Zm9ybSA9IHhmb3JtO1xuICB0aGlzLmYgPSBmO1xuICB0aGlzLmRyb3BwaW5nID0gdHJ1ZTtcbn1cblxuRHJvcFdoaWxlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnhmb3JtLmluaXQoKTtcbn07XG5cbkRyb3BXaGlsZS5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdGhpcy54Zm9ybS5yZXN1bHQodik7XG59O1xuXG5Ecm9wV2hpbGUucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gIGlmKHRoaXMuZHJvcHBpbmcpIHtcbiAgICBpZih0aGlzLmYoaW5wdXQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuZHJvcHBpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMueGZvcm0uc3RlcChyZXN1bHQsIGlucHV0KTtcbn07XG5cbmZ1bmN0aW9uIGRyb3BXaGlsZShjb2xsLCBmLCBjdHgpIHtcbiAgaWYoaXNGdW5jdGlvbihjb2xsKSkgeyBjdHggPSBmOyBmID0gY29sbDsgY29sbCA9IG51bGw7IH1cbiAgZiA9IGJvdW5kKGYsIGN0eCk7XG5cbiAgaWYoY29sbCkge1xuICAgIHJldHVybiBzZXEoY29sbCwgZHJvcFdoaWxlKGYpKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih4Zm9ybSkge1xuICAgIHJldHVybiBuZXcgRHJvcFdoaWxlKGYsIHhmb3JtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBQYXJ0aXRpb24obiwgeGZvcm0pIHtcbiAgdGhpcy5uID0gbjtcbiAgdGhpcy5pID0gMDtcbiAgdGhpcy54Zm9ybSA9IHhmb3JtO1xuICB0aGlzLnBhcnQgPSBuZXcgQXJyYXkobik7XG59XG5cblBhcnRpdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy54Zm9ybS5pbml0KCk7XG59O1xuXG5QYXJ0aXRpb24ucHJvdG90eXBlLnJlc3VsdCA9IGZ1bmN0aW9uKHYpIHtcbiAgaWYgKHRoaXMuaSA+IDApIHtcbiAgICByZXR1cm4gZW5zdXJlVW5yZWR1Y2VkKHRoaXMueGZvcm0uc3RlcCh2LCB0aGlzLnBhcnQuc2xpY2UoMCwgdGhpcy5pKSkpO1xuICB9XG4gIHJldHVybiB0aGlzLnhmb3JtLnJlc3VsdCh2KTtcbn07XG5cblBhcnRpdGlvbi5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgdGhpcy5wYXJ0W3RoaXMuaV0gPSBpbnB1dDtcbiAgdGhpcy5pICs9IDE7XG4gIGlmICh0aGlzLmkgPT09IHRoaXMubikge1xuICAgIHZhciBvdXQgPSB0aGlzLnBhcnQuc2xpY2UoMCwgdGhpcy5uKTtcbiAgICB0aGlzLnBhcnQgPSBuZXcgQXJyYXkodGhpcy5uKTtcbiAgICB0aGlzLmkgPSAwO1xuICAgIHJldHVybiB0aGlzLnhmb3JtLnN0ZXAocmVzdWx0LCBvdXQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBwYXJ0aXRpb24oY29sbCwgbikge1xuICBpZiAoaXNOdW1iZXIoY29sbCkpIHtcbiAgICBuID0gY29sbDsgY29sbCA9IG51bGw7XG4gIH1cblxuICBpZiAoY29sbCkge1xuICAgIHJldHVybiBzZXEoY29sbCwgcGFydGl0aW9uKG4pKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih4Zm9ybSkge1xuICAgIHJldHVybiBuZXcgUGFydGl0aW9uKG4sIHhmb3JtKTtcbiAgfTtcbn1cblxudmFyIE5PVEhJTkcgPSB7fTtcblxuZnVuY3Rpb24gUGFydGl0aW9uQnkoZiwgeGZvcm0pIHtcbiAgLy8gVE9ETzogdGFrZSBhbiBcIm9wdHNcIiBvYmplY3QgdGhhdCBhbGxvd3MgdGhlIHVzZXIgdG8gc3BlY2lmeVxuICAvLyBlcXVhbGl0eVxuICB0aGlzLmYgPSBmO1xuICB0aGlzLnhmb3JtID0geGZvcm07XG4gIHRoaXMucGFydCA9IFtdO1xuICB0aGlzLmxhc3QgPSBOT1RISU5HO1xufVxuXG5QYXJ0aXRpb25CeS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy54Zm9ybS5pbml0KCk7XG59O1xuXG5QYXJ0aXRpb25CeS5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24odikge1xuICB2YXIgbCA9IHRoaXMucGFydC5sZW5ndGg7XG4gIGlmIChsID4gMCkge1xuICAgIHJldHVybiBlbnN1cmVVbnJlZHVjZWQodGhpcy54Zm9ybS5zdGVwKHYsIHRoaXMucGFydC5zbGljZSgwLCBsKSkpO1xuICB9XG4gIHJldHVybiB0aGlzLnhmb3JtLnJlc3VsdCh2KTtcbn07XG5cblBhcnRpdGlvbkJ5LnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuZihpbnB1dCk7XG4gIGlmIChjdXJyZW50ID09PSB0aGlzLmxhc3QgfHwgdGhpcy5sYXN0ID09PSBOT1RISU5HKSB7XG4gICAgdGhpcy5wYXJ0LnB1c2goaW5wdXQpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRoaXMueGZvcm0uc3RlcChyZXN1bHQsIHRoaXMucGFydCk7XG4gICAgdGhpcy5wYXJ0ID0gW2lucHV0XTtcbiAgfVxuICB0aGlzLmxhc3QgPSBjdXJyZW50O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gcGFydGl0aW9uQnkoY29sbCwgZiwgY3R4KSB7XG4gIGlmIChpc0Z1bmN0aW9uKGNvbGwpKSB7IGN0eCA9IGY7IGYgPSBjb2xsOyBjb2xsID0gbnVsbDsgfVxuICBmID0gYm91bmQoZiwgY3R4KTtcblxuICBpZiAoY29sbCkge1xuICAgIHJldHVybiBzZXEoY29sbCwgcGFydGl0aW9uQnkoZikpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHhmb3JtKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aXRpb25CeShmLCB4Zm9ybSk7XG4gIH07XG59XG5cbi8vIHB1cmUgdHJhbnNkdWNlcnMgKGNhbm5vdCB0YWtlIGNvbGxlY3Rpb25zKVxuXG5mdW5jdGlvbiBDYXQoeGZvcm0pIHtcbiAgdGhpcy54Zm9ybSA9IHhmb3JtO1xufVxuXG5DYXQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm0uaW5pdCgpO1xufTtcblxuQ2F0LnByb3RvdHlwZS5yZXN1bHQgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0aGlzLnhmb3JtLnJlc3VsdCh2KTtcbn07XG5cbkNhdC5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgdmFyIHhmb3JtID0gdGhpcy54Zm9ybTtcbiAgdmFyIG5ld3hmb3JtID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHhmb3JtLmluaXQoKTtcbiAgICB9LFxuICAgIHJlc3VsdDogZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfSxcbiAgICBzdGVwOiBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gICAgICB2YXIgdmFsID0geGZvcm0uc3RlcChyZXN1bHQsIGlucHV0KTtcbiAgICAgIHJldHVybiBpc1JlZHVjZWQodmFsKSA/IGRlcmVmKHZhbCkgOiB2YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlZHVjZShpbnB1dCwgbmV3eGZvcm0sIHJlc3VsdCk7XG59O1xuXG5mdW5jdGlvbiBjYXQoeGZvcm0pIHtcbiAgcmV0dXJuIG5ldyBDYXQoeGZvcm0pO1xufVxuXG5mdW5jdGlvbiBtYXBjYXQoZiwgY3R4KSB7XG4gIGYgPSBib3VuZChmLCBjdHgpO1xuICByZXR1cm4gY29tcG9zZShtYXAoZiksIGNhdCk7XG59XG5cbi8vIGNvbGxlY3Rpb24gaGVscGVyc1xuXG5mdW5jdGlvbiBwdXNoKGFyciwgeCkge1xuICBhcnIucHVzaCh4KTtcbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gbWVyZ2Uob2JqLCB4KSB7XG4gIGlmKGlzQXJyYXkoeCkgJiYgeC5sZW5ndGggPT09IDIpIHtcbiAgICBvYmpbeFswXV0gPSB4WzFdO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoeCk7XG4gICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpPGxlbjsgaSsrKSB7XG4gICAgICBvYmpba2V5c1tpXV0gPSB4W2tleXNbaV1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG52YXIgYXJyYXlSZWR1Y2VyID0ge1xuICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gW107XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24odikge1xuICAgIHJldHVybiB2O1xuICB9LFxuICBzdGVwOiBwdXNoXG59XG5cbnZhciBvYmpSZWR1Y2VyID0ge1xuICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge307XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24odikge1xuICAgIHJldHVybiB2O1xuICB9LFxuICBzdGVwOiBtZXJnZVxufTtcblxuZnVuY3Rpb24gZ2V0UmVkdWNlcihjb2xsKSB7XG4gIGlmKGlzQXJyYXkoY29sbCkpIHtcbiAgICByZXR1cm4gYXJyYXlSZWR1Y2VyO1xuICB9XG4gIGVsc2UgaWYoaXNPYmplY3QoY29sbCkpIHtcbiAgICByZXR1cm4gb2JqUmVkdWNlcjtcbiAgfVxuICBlbHNlIGlmKGZ1bGZpbGxzUHJvdG9jb2woY29sbCwgJ3RyYW5zZm9ybWVyJykpIHtcbiAgICByZXR1cm4gZ2V0UHJvdG9jb2xQcm9wZXJ0eShjb2xsLCAndHJhbnNmb3JtZXInKTtcbiAgfVxuICB0aHJvd1Byb3RvY29sRXJyb3IoJ2dldFJlZHVjZXInLCBjb2xsKTtcbn1cblxuLy8gYnVpbGRpbmcgbmV3IGNvbGxlY3Rpb25zXG5cbmZ1bmN0aW9uIHRvQXJyYXkoY29sbCwgeGZvcm0pIHtcbiAgaWYoIXhmb3JtKSB7XG4gICAgcmV0dXJuIHJlZHVjZShjb2xsLCBhcnJheVJlZHVjZXIsIFtdKTtcbiAgfVxuICByZXR1cm4gdHJhbnNkdWNlKGNvbGwsIHhmb3JtLCBhcnJheVJlZHVjZXIsIFtdKTtcbn1cblxuZnVuY3Rpb24gdG9PYmooY29sbCwgeGZvcm0pIHtcbiAgaWYoIXhmb3JtKSB7XG4gICAgcmV0dXJuIHJlZHVjZShjb2xsLCBvYmpSZWR1Y2VyLCB7fSk7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZHVjZShjb2xsLCB4Zm9ybSwgb2JqUmVkdWNlciwge30pO1xufVxuXG5mdW5jdGlvbiB0b0l0ZXIoY29sbCwgeGZvcm0pIHtcbiAgaWYoIXhmb3JtKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yKGNvbGwpO1xuICB9XG4gIHJldHVybiBuZXcgTGF6eVRyYW5zZm9ybWVyKHhmb3JtLCBjb2xsKTtcbn1cblxuZnVuY3Rpb24gc2VxKGNvbGwsIHhmb3JtKSB7XG4gIGlmKGlzQXJyYXkoY29sbCkpIHtcbiAgICByZXR1cm4gdHJhbnNkdWNlKGNvbGwsIHhmb3JtLCBhcnJheVJlZHVjZXIsIFtdKTtcbiAgfVxuICBlbHNlIGlmKGlzT2JqZWN0KGNvbGwpKSB7XG4gICAgcmV0dXJuIHRyYW5zZHVjZShjb2xsLCB4Zm9ybSwgb2JqUmVkdWNlciwge30pO1xuICB9XG4gIGVsc2UgaWYoZnVsZmlsbHNQcm90b2NvbChjb2xsLCAndHJhbnNmb3JtZXInKSkge1xuICAgIHZhciB0cmFuc2Zvcm1lciA9IGdldFByb3RvY29sUHJvcGVydHkoY29sbCwgJ3RyYW5zZm9ybWVyJyk7XG4gICAgcmV0dXJuIHRyYW5zZHVjZShjb2xsLCB4Zm9ybSwgdHJhbnNmb3JtZXIsIHRyYW5zZm9ybWVyLmluaXQoKSk7XG4gIH1cbiAgZWxzZSBpZihmdWxmaWxsc1Byb3RvY29sKGNvbGwsICdpdGVyYXRvcicpKSB7XG4gICAgcmV0dXJuIG5ldyBMYXp5VHJhbnNmb3JtZXIoeGZvcm0sIGNvbGwpO1xuICB9XG4gIHRocm93UHJvdG9jb2xFcnJvcignc2VxdWVuY2UnLCBjb2xsKTtcbn1cblxuZnVuY3Rpb24gaW50byh0bywgeGZvcm0sIGZyb20pIHtcbiAgaWYoaXNBcnJheSh0bykpIHtcbiAgICByZXR1cm4gdHJhbnNkdWNlKGZyb20sIHhmb3JtLCBhcnJheVJlZHVjZXIsIHRvKTtcbiAgfVxuICBlbHNlIGlmKGlzT2JqZWN0KHRvKSkge1xuICAgIHJldHVybiB0cmFuc2R1Y2UoZnJvbSwgeGZvcm0sIG9ialJlZHVjZXIsIHRvKTtcbiAgfVxuICBlbHNlIGlmKGZ1bGZpbGxzUHJvdG9jb2wodG8sICd0cmFuc2Zvcm1lcicpKSB7XG4gICAgcmV0dXJuIHRyYW5zZHVjZShmcm9tLFxuICAgICAgICAgICAgICAgICAgICAgeGZvcm0sXG4gICAgICAgICAgICAgICAgICAgICBnZXRQcm90b2NvbFByb3BlcnR5KHRvLCAndHJhbnNmb3JtZXInKSxcbiAgICAgICAgICAgICAgICAgICAgIHRvKTtcbiAgfVxuICB0aHJvd1Byb3RvY29sRXJyb3IoJ2ludG8nLCB0byk7XG59XG5cbi8vIGxhemluZXNzXG5cbnZhciBzdGVwcGVyID0ge1xuICByZXN1bHQ6IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gaXNSZWR1Y2VkKHYpID8gZGVyZWYodikgOiB2O1xuICB9LFxuICBzdGVwOiBmdW5jdGlvbihsdCwgeCkge1xuICAgIGx0Lml0ZW1zLnB1c2goeCk7XG4gICAgcmV0dXJuIGx0LnJlc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gU3RlcHBlcih4Zm9ybSwgaXRlcikge1xuICB0aGlzLnhmb3JtID0geGZvcm0oc3RlcHBlcik7XG4gIHRoaXMuaXRlciA9IGl0ZXI7XG59XG5cblN0ZXBwZXIucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbihsdCkge1xuICB2YXIgbGVuID0gbHQuaXRlbXMubGVuZ3RoO1xuICB3aGlsZShsdC5pdGVtcy5sZW5ndGggPT09IGxlbikge1xuICAgIHZhciBuID0gdGhpcy5pdGVyLm5leHQoKTtcbiAgICBpZihuLmRvbmUgfHwgaXNSZWR1Y2VkKG4udmFsdWUpKSB7XG4gICAgICAvLyBmaW5hbGl6ZVxuICAgICAgdGhpcy54Zm9ybS5yZXN1bHQodGhpcyk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBzdGVwXG4gICAgdGhpcy54Zm9ybS5zdGVwKGx0LCBuLnZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBMYXp5VHJhbnNmb3JtZXIoeGZvcm0sIGNvbGwpIHtcbiAgdGhpcy5pdGVyID0gaXRlcmF0b3IoY29sbCk7XG4gIHRoaXMuaXRlbXMgPSBbXTtcbiAgdGhpcy5zdGVwcGVyID0gbmV3IFN0ZXBwZXIoeGZvcm0sIGl0ZXJhdG9yKGNvbGwpKTtcbn1cblxuTGF6eVRyYW5zZm9ybWVyLnByb3RvdHlwZVtwcm90b2NvbHMuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzO1xufVxuXG5MYXp5VHJhbnNmb3JtZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zdGVwKCk7XG5cbiAgaWYodGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHRoaXMuaXRlbXMucG9wKCksXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gIH1cbn07XG5cbkxhenlUcmFuc2Zvcm1lci5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKCkge1xuICBpZighdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICB0aGlzLnN0ZXBwZXIuc3RlcCh0aGlzKTtcbiAgfVxufVxuXG4vLyB1dGlsXG5cbmZ1bmN0aW9uIHJhbmdlKG4pIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheShuKTtcbiAgZm9yKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyW2ldID0gaTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZWR1Y2U6IHJlZHVjZSxcbiAgdHJhbnNmb3JtZXI6IHRyYW5zZm9ybWVyLFxuICBSZWR1Y2VkOiBSZWR1Y2VkLFxuICBpdGVyYXRvcjogaXRlcmF0b3IsXG4gIHB1c2g6IHB1c2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgdHJhbnNkdWNlOiB0cmFuc2R1Y2UsXG4gIHNlcTogc2VxLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICB0b09iajogdG9PYmosXG4gIHRvSXRlcjogdG9JdGVyLFxuICBpbnRvOiBpbnRvLFxuICBjb21wb3NlOiBjb21wb3NlLFxuICBtYXA6IG1hcCxcbiAgZmlsdGVyOiBmaWx0ZXIsXG4gIHJlbW92ZTogcmVtb3ZlLFxuICBjYXQ6IGNhdCxcbiAgbWFwY2F0OiBtYXBjYXQsXG4gIGtlZXA6IGtlZXAsXG4gIGRlZHVwZTogZGVkdXBlLFxuICB0YWtlOiB0YWtlLFxuICB0YWtlV2hpbGU6IHRha2VXaGlsZSxcbiAgZHJvcDogZHJvcCxcbiAgZHJvcFdoaWxlOiBkcm9wV2hpbGUsXG4gIHBhcnRpdGlvbjogcGFydGl0aW9uLFxuICBwYXJ0aXRpb25CeTogcGFydGl0aW9uQnksXG4gIHJhbmdlOiByYW5nZSxcblxuICBwcm90b2NvbHM6IHByb3RvY29scyxcbiAgTGF6eVRyYW5zZm9ybWVyOiBMYXp5VHJhbnNmb3JtZXJcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90cmFuc2R1Y2Vycy5qcy90cmFuc2R1Y2Vycy5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIiwiZmlsZSI6IjEuanMifQ==");

/***/ }
/******/ ]);